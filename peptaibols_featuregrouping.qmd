---
title: "peptaibol_list"
format: html
editor: visual
---

#Bibliotecas

```{r}
library(dplyr)
library(readxl)
library(tidyverse)
library(pheatmap)
library(RColorBrewer)
library(openxlsx)
library(purrr)
library(stringr)
```

#Dados. Insira aqui as listas pré-processadas em softwares como MZmine, OpenMS, e outros.

```{r}
peptaibol_list <- read_xlsx("lista_compilada.xlsx") #lista filtrada para os 20% mais intensos

mzmine_list <- read_xlsx("mzmine_list.xlsx") #lista completa gerada a partir do alinhamento de todas as espécies

peptaibol_list <- peptaibol_list %>%
  rename(monoisotopic_mass = `monoisotopic mass`) |> 
  arrange(monoisotopic_mass) 

```

#Parâmetros

```{r}
#parametro para tolerância de massa entre os picos selecionados
mz_tolerance_filter <- 0.05

#Parâmetros para a identificação de picos isotópicos
mz_iso_M1_diff <- 1.00335
mz_iso_M2_diff <- 2.0067

#tempo de retenção - tolerância
rt_tolerance <- 0.5

mz_tolerance <- 0.05
serie_mass_diff_1CH2 <- 14.01565
serie_mass_diff_2CH2 <- 28.03130



cat("Número de linhas antes da filtragem:", nrow(peptaibol_list), "\n")
```

#Filtragem_semelhantes

```{r}
#LIMPEZA DOS DADOS
peptaibol_list_filtrado <- peptaibol_list %>%
  group_by(species) %>%
  arrange(monoisotopic_mass) %>%
  mutate(similarity_group = cumsum(c(TRUE, diff(monoisotopic_mass) > mz_tolerance_filter))) %>%
  group_by(species, similarity_group) %>%
  slice_max(order_by = area, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  select(-similarity_group)
#OBS: corrigir nesse ponto, para que possa ser incluído também como parâmetro o rt

cat("Número de linhas após a filtragem:", nrow(peptaibol_list_filtrado), "\n")
```

#Picos Isotópicos
```{r}

peptaibol_list_filtrado <- peptaibol_list_filtrado %>% arrange(monoisotopic_mass)

# 2. INICIALIZAR a coluna do grupo e um contador.
peptaibol_list_filtrado$isotopic_group <- NA
isotopic_group_counter <- 1

# Itera sobre a lista para encontrar picos isotópicos
for (i in 1:nrow(peptaibol_list_filtrado)) {
  if (is.na(peptaibol_list_filtrado$isotopic_group[i])) {
    current_mass <- peptaibol_list_filtrado$monoisotopic_mass[i]
    current_rt <- peptaibol_list_filtrado$rt[i]
    
    match_M1_index <- which(
      abs(peptaibol_list_filtrado$rt - current_rt) <= rt_tolerance &
      abs(peptaibol_list_filtrado$monoisotopic_mass - current_mass - mz_iso_M1_diff) <= mz_tolerance_filter &
      is.na(peptaibol_list_filtrado$isotopic_group)
    )
    
    match_M2_index <- which(
      abs(peptaibol_list_filtrado$rt - current_rt) <= rt_tolerance &
      abs(peptaibol_list_filtrado$monoisotopic_mass - current_mass - mz_iso_M2_diff) <= mz_tolerance_filter &
      is.na(peptaibol_list_filtrado$isotopic_group)
    )
    
    if (length(match_M1_index) > 0 || length(match_M2_index) > 0) {
      peptaibol_list_filtrado$isotopic_group[i] <- isotopic_group_counter
      peptaibol_list_filtrado$isotopic_group[match_M1_index] <- isotopic_group_counter
      peptaibol_list_filtrado$isotopic_group[match_M2_index] <- isotopic_group_counter
      isotopic_group_counter <- isotopic_group_counter + 1
    }
  }
}


# Para visualizar os resultados, você pode filtrar e ordenar
isotopic_groups <- peptaibol_list_filtrado %>%
  filter(!is.na(isotopic_group)) %>%
  arrange(isotopic_group, monoisotopic_mass)
```

#Séries-peptídeos
```{r}
peptaibol_list_filtrado <- peptaibol_list_filtrado %>% arrange(monoisotopic_mass)
peptaibol_list_filtrado$serie_group <- NA
serie_group_counter <- 1

for (i in 1:nrow(peptaibol_list_filtrado)) {
  if (is.na(peptaibol_list_filtrado$serie_group[i])) {
    current_mass <- peptaibol_list_filtrado$monoisotopic_mass[i]
    
    # Busca por picos com +1 CH₂ (~14 Da)
    match_1CH2_index <- which(
      abs(peptaibol_list_filtrado$monoisotopic_mass - current_mass - serie_mass_diff_1CH2) <= mz_tolerance_filter &
      is.na(peptaibol_list_filtrado$serie_group)
    )
    
    # Busca por picos com +2 CH₂ (~28 Da)
    match_2CH2_index <- which(
      abs(peptaibol_list_filtrado$monoisotopic_mass - current_mass - serie_mass_diff_2CH2) <= mz_tolerance_filter &
      is.na(peptaibol_list_filtrado$serie_group)
    )
    
    if (length(match_1CH2_index) > 0 || length(match_2CH2_index) > 0) {
      peptaibol_list_filtrado$serie_group[i] <- serie_group_counter
      peptaibol_list_filtrado$serie_group[c(match_1CH2_index, match_2CH2_index)] <- serie_group_counter
      serie_group_counter <- serie_group_counter + 1
    }
  }
}
#Obs: adicionar camada no algoritmo para considerar os tempos de retenção (rt)
```

#Massa representativa: Isso irá auxiliar nos processos de montagem da matriz. Associando sempre um pep_id à massa representativa de determinados picos. À essa massa representativa será dado o valor de massa monoisotópica dos grupos de picos homólogos (isótopos) que possua o menor valor. Garantindo que estamos lidando com moléculas de carbono_12
```{r}
representative_masses <- peptaibol_list_filtrado %>%
  filter(!is.na(isotopic_group)) %>%
  group_by(isotopic_group) %>%
  summarise(representative_mass = min(monoisotopic_mass))

peptaibol_list_final <- peptaibol_list_filtrado %>%
  left_join(representative_masses, by = "isotopic_group") %>%
  mutate(representative_mass = ifelse(is.na(representative_mass), monoisotopic_mass, representative_mass))
```

#Isômeros_Match
```{r}
peptaibol_list_final$match_group <- NA
match_group_counter <- 1

for (i in 1:nrow(peptaibol_list_final)) {
  if (is.na(peptaibol_list_final$match_group[i])) {
    
    # Pega as propriedades do pico atual
    current_rep_mass <- peptaibol_list_final$representative_mass[i]
    current_rt <- peptaibol_list_final$rt[i]
    
    # A busca agora verifica AMBAS as condições: massa representativa E tempo de retenção
    matches_indices <- which(
      
      # Condição 1: A diferença de massa representativa está dentro da tolerância
      abs(peptaibol_list_final$representative_mass - current_rep_mass) <= mz_tolerance_filter &
        
      # Condição 2: A diferença de RT está dentro da tolerância
      abs(peptaibol_list_final$rt - current_rt) <= rt_tolerance
    )
    
    # Apenas agrupa se encontrar pelo menos um outro pico (em outra espécie)
    # que atenda a AMBOS os critérios.
    if (length(matches_indices) > 1) {
      peptaibol_list_final$match_group[matches_indices] <- match_group_counter
      match_group_counter <- match_group_counter + 1
    }
  }
}



```

#Organização dos índices e nomenclatura

```{r}

get_initials <- function(specie_name) {
  # Divide o nome por espaços ou underscores
  words <- strsplit(specie_name, "[ _]+")[[1]]
  # Pega a primeira letra de cada palavra
  initials <- substring(words, 1, 1)
  # Junta as letras e converte para minúsculo
  return(tolower(paste(initials, collapse = "")))
}

# --- Aplicação da lógica para criar a coluna pep_group ---
peptaibol_list_final <- peptaibol_list_final %>%
  # rowwise() garante que a função get_initials seja aplicada a cada linha individualmente
  rowwise() %>%
  mutate(
    initials = get_initials(species)
  ) %>%
  ungroup() %>% # ungroup() é importante para que as próximas operações sejam mais rápidas
  mutate(
    pep_group = ifelse( #cria uma condição de "se" para caso seja saciado, prosseguir com a iteração
      !is.na(match_group), #dataframe onde será observado as condições estabelecidas
      paste(initials, match_group, sep = "_"), #condição TRUE
      paste(initials, as.integer(representative_mass), sep = "_") #condição FALSE
    )
  ) %>%
  select(-initials)


# Filtrar para mostrar apenas as linhas que foram agrupadas
matched_peaks <- peptaibol_list_final %>%
  filter(!is.na(match_group)) %>%
  arrange(match_group, representative_mass) # Ordenar por grupo e depois por m/z


matched_peaks <- matched_peaks %>%
  mutate(
    pep_id = paste0("pep_", as.integer(monoisotopic_mass)),
    log10_area = log10(area)
  )
peptaibol_list_final <- peptaibol_list_final |> 
  mutate(
    pep_id = paste0("pep_", as.integer(monoisotopic_mass)),
    log10_area = log10(area)
  )

####OBS_1: adicionar uma etapa de filtragem/seleção de linhas duplicadas para uma mesma espécie - por quê? Isso trará problemas para a realização da matriz larga, pois não deverá ter linhas duplicadas para uma mesma espécie. Solução!: filtrar por slice_max, assim todos os picos duplicados para uma mesma espécie terão um representante de massa, *com um mesmo RT*, condiz com a maior área entre os picos isótopos encontrados.Por fim, trocar a forma de nomenclatura dos pep_id para que id = as.integer(representative_mass).####
####OBS_2: A segunda etapa é avaliar caso os pep_id sejam semelhantes entre espécies diferentes, agrupar os pep_id semelhantes que tenham mesmo rt, caso contrário, criar outro pep_id seguido de "_"e um "counter" para que possamos agrupar todos aqueles que tenham mesmo rt (ou seja, efetivamente homólogos e não isômeros).####

peptaibol_grouped <- peptaibol_list_final |> 
  select(pep_id, pep_group, species, representative_mass, monoisotopic_mass, log10_area, rt, match_group, isotopic_group, serie_group)

#reordenando as colunas
matched_peaks_final <- matched_peaks |> 
  select(pep_id, pep_group, species, representative_mass, monoisotopic_mass, log10_area, rt, peptaibol_group, match_group, isotopic_group, serie_group)

#exportando os dados
write.csv(peptaibol_grouped, 
          file = "pepaibol_all.csv", 
          row.names = FALSE)

write.csv(matched_peaks_final, 
          file = "pep_shared_final.csv", 
          row.names = FALSE)


# Imprimir a tabela de resultados no console
print("Picos com m/z semelhante encontrados:")
print(matched_peaks[, c("species", "rt", "peptaibol_group", "match_group", "monoisotopic_mass")])
```

#Matriz - Transformando os resultados em tabela larga, isto irá permitir análises futuras como criação de heatmaps e análises de PCA, facilitando a visualização dos dados de bioatividade posteriormente

```{r}

# 1. Usar a área MÁXIMA como condição para selecionar o pico representante de cada espécie

data_for_pivot <- peptaibol_list_final %>%
  group_by(pep_id, species) %>%
  
  #Cria um resumo usando a área MÁXIMA encontrada para o grupo.
  # Isso garante que estamos usando o pico mais intenso como quantificador.
  summarise(representative_area = max(area), .groups = 'drop') %>%
  # Calcula o log10 da área representativa + 1
  mutate(log10_area = log10(representative_area + 1))

pep_matrix_wide <- data_for_pivot %>%
  pivot_wider(
    id_cols = pep_id,
    names_from = species,
    values_from = log10_area
  )


pep_matrix_wide[is.na(pep_matrix_wide)] <- 0 #Substitui NA por 0 (número)

pep_matrix_wide <- pep_matrix_wide %>%
  mutate(
    # A função across() aplica uma operação a um conjunto de colunas.
    across(where(is.numeric), ~round(., 2))
  )

print(head(pep_matrix_wide))

```

# Transformação_MZmine

```{r}


mzmine_list_area <- mzmine_list |> 
  mutate(pep_id = paste0("pep_", as.integer(monoisotopic_mass))) |> 
   select(pep_id, monoisotopic_mass,
         rt, ends_with(":area")) |> 
  pivot_longer(
    cols = ends_with(":area"), 
    names_to = "sample_name",
    values_to = "area"
  ) %>%
  
  # Filtra picos com área zero
  filter(area > 0) %>%
  mutate(
    # Extrai a base do nome (ex: "chloroleuca_12")
    specie_base = str_remove(sample_name, "\\.mzML:area$"),
    # Remove os números do isolado (ex: "_12") para obter apenas a espécie
    specie_base = str_remove(specie_base, "_[0-9]+$"),
    # Adiciona o prefixo do gênero para corresponder à sua lista principal
    specie = paste("Clonostachys", specie_base, sep = " ")
  ) %>%
  
  # Seleciona as colunas finais que vamos usar
  select(pep_id, monoisotopic_mass, rt, area, specie)

#OBS: pensar em como definir os pep_id da lista completa proveniente do mzmine. Isso irá auxiliar nos processos posteriores de gap-filling. 
#OBS_2: O rt selecionado nesta etapa se refere apenas ao rt médio encontrado para todas as espécies que tiveram suas moléculas (features) alinhados. Solução: Buscar os rt respectivos de cada molécula, caso elas se alinhem em um mesmo rt - rt_tolerance, considerar um mesmo pep_id, caso contrário definir outro pep_id como mencionado anteriormente.

```


#Gap-filling

```{r}

#Os dados de busca (mzmine_list) servirão como a banco de bados para encontrar as massas representativas que já foram identificadas na matriz pep_matrix_wide. 

clean_names <- function(x) str_to_lower(str_squish(x))

peptaibol_list_final <- peptaibol_list_final %>%
  mutate(specie = clean_names(species))

mzmine_list_area <- mzmine_list_area %>%
  mutate(specie = clean_names(specie))

names(pep_matrix_wide)[-1] <- clean_names(names(pep_matrix_wide)[-1])


pep_id_definitions <- mzmine_list_area %>%
  group_by(pep_id, specie) %>% #nessa etapa os pep_id já devem ter sido criados
  slice_max(order_by = area, n = 1, with_ties = FALSE) %>%  # pega o pico mais intenso
  ungroup() %>%
  select(
    pep_id,
    area,
    specie,
    representative_mass = monoisotopic_mass,
    representative_rt   = rt
  )
#OBS: caso haja mais de um pep_id, pode ser que haja um confundimento de picos mais intensos. Em outras palavras, supondo que haja dois picos de massas iguais (isômeros), no entanto com rt diferente. Não pode-se garantir que sejam a mesma molécula. Logo, para que esse algoritmo seja mais preciso, é necessário em uma etapa anterior realizar essa discriminação para esta etapa.
#OBS_2: Olhando um pouco mais esta lista criada, pep_id_definitions, ela esta criando um uma massa representativa e um rt médio pois está sendo importado somente os dados médios

gaps_to_fill <- pep_matrix_wide %>%
  pivot_longer(cols = -pep_id, names_to = "specie", values_to = "log10_area") %>%
  filter(log10_area == 0) %>%
  left_join(pep_id_definitions, by = c("pep_id", "specie"))


missing_defs <- gaps_to_fill %>% filter(is.na(representative_mass) | is.na(representative_rt))
#if(nrow(missing_defs) > 0) {
 # message("Existem lacunas sem definição de representative_mass/rt (possível mismatch de espécie).")
  #print(distinct(missing_defs, pep_id, specie) %>% head(50))
#}

# --- 8.2: Definir Parâmetros para a Busca ---
mz_tolerance_fill <- 0.05
rt_tolerance_fill <- 0.4
area_tolerance_fill <- 1E3


# --- 5) Procurar nos dados da mzmine (com filtros)
filled_gaps <- gaps_to_fill %>%
  mutate(
    found_area = pmap_dbl(
      list(specie, representative_mass, representative_rt),
      function(specie_i, mz_i, rt_i) {
        if(is.na(specie_i) || is.na(mz_i) || is.na(rt_i)) return(NA_real_)
        matches <- mzmine_list_area %>%
          filter(
            specie == specie_i,
            abs(monoisotopic_mass - mz_i) <= mz_tolerance_fill,
            abs(rt - rt_i) <= rt_tolerance_fill,
            area >= area_tolerance_fill
          )
        if(nrow(matches) == 0) return(NA_real_) else return(max(matches$area, na.rm = TRUE))
      }
    )
  )

final_filled_values <- filled_gaps %>%
  filter(!is.na(found_area)) %>%
  mutate(log10_area_filled = log10(found_area + 1)) %>%
  select(pep_id, specie, found_area)

pep_matrix_filled <- pep_matrix_wide %>%
  pivot_longer(cols = -pep_id, names_to = "specie", values_to = "log10_area") %>%
  left_join(final_filled_values, by = c("pep_id", "specie")) %>%
  mutate(
    final_log10_area = ifelse(!is.na(log10_area_filled), log10_area_filled, log10_area)
  ) %>%
  select(pep_id, specie, final_log10_area) %>%
  pivot_wider(
    id_cols = pep_id,
    names_from = specie,
    values_from = final_log10_area
  ) %>%
  mutate(
    across(where(is.numeric), ~round(., 2))
  )
# Visualiza a nova matriz preenchida
print(head(pep_matrix_filled))

matriz_excel <- as.data.frame(pep_matrix_filled)

print(head(matriz_excel))

matriz_peptaibols <- "matriz_peptaibols.xlsx"

write.xlsx(
  matriz_excel,
  file = matriz_peptaibols,
  asTable = TRUE,
  overwrite = TRUE
)

cat("matriz_peptaibols.xlsx", matriz_excel, "salvo com sucesso!")
```

#Anotação_alvos

```{r}
targets_to_add <- data.frame(
  # Usaremos o nome da molécula como o novo pep_id
  pep_id = c("pep_Clonostachin", "pep_Clonostachin_B", "pep_Integramide_B"),
  
  # A massa monoisotópica esperada para cada uma
  target_mz = c(1666.98, 1680.95, 1645.01),
  
  # O tempo de retenção (RT) aproximado onde você espera encontrá-las
  target_rt = c(11.18, 9.75, 10.53)
)

#OBS: Criar uma lista (dataframe) de uma biblioteca de alvos anotados. (Neste caso de clonostachys, para este momento foram apenas 3 compostos anotados. Conforme há a incorporação de mais moléculas, é interessante ter um banco de dados/ uma biblioteca de compostos com suas respectivas massas monoisotópicas, tempo de retenção e entre outros fatores. Além disso, uma biblioteca contendo os espectros MS2 também se faz útil para conseguir observar possíveis quebras características)

found_targets_long <- targets_to_add %>%
  # pmap_dfr executa uma função para cada linha da tabela de alvos
  purrr::pmap_dfr(function(pep_id, target_mass, target_rt) {
    
    # Busca na lista completa do MZmine
    mzmine_list_area %>%
      filter(
        abs(monoisotopic_mass - target_mass) <= mz_tolerance_fill,
        abs(rt - target_rt) <= rt_tolerance_fill,
        area >= area_tolerance_fill
      ) %>%
      # Se encontrar, adiciona o nome do alvo (pep_id) à linha
      mutate(pep_id = pep_id)
  })

if (nrow(found_targets_long) > 0) {
  new_molecules_matrix <- found_targets_long %>%
    # Agrupa para pegar a área máxima por espécie (caso haja múltiplos isolados/picos)
    group_by(pep_id, specie) %>%
    summarise(max_area = max(area), .groups = 'drop') %>%
    # Calcula o log10 da área
    mutate(log10_area = log10(max_area + 1)) %>%
    # Pivota para o formato largo, igual à matriz principal
    pivot_wider(
      id_cols = pep_id,
      names_from = specie,
      values_from = log10_area
    )
} else {
  # Cria uma matriz vazia se nenhum alvo for encontrado
  new_molecules_matrix <- NULL
  message("Nenhuma das moléculas alvo foi encontrada na lista do MZmine com os critérios definidos.")
}

#filtrar para apenas as espécies principais/ aqueles que estão presentes na matriz principal de análise
new_molecules_matrix <- new_molecules_matrix |> 
  mutate(across(where(is.numeric), ~replace_na(.,0))) |> 
  mutate(across(where(is.numeric), ~round(., 2))) |> 
  select(pep_id, `clonostachys chloroleuca`, `clonostachys pseudochroleuca`, `clonostachys rogersoniana`)

if (!is.null(new_molecules_matrix)) {
  
  # A função bind_rows do dplyr é perfeita para empilhar as duas tabelas
  pep_matrix_final_annotate <- bind_rows(pep_matrix_filled, new_molecules_matrix) 
} else {
  # Se nenhuma molécula nova foi encontrada, a matriz final é a mesma do gap-filling
  pep_matrix_final_annotate <- pep_matrix_filled
}

pep_matrix_final_annotate <- pep_matrix_final_annotate %>%
  mutate(pep_id = case_when(
    pep_id == "pep_1666" ~ "pep_Clonostachin",
    pep_id == "pep_1680" ~ "pep_Clonostachin_B",
    pep_id == "pep_1645" ~ "pep_Integramide_B",
    pep_id == "pep_1630" ~ "pep_Integramide_A",
    pep_id == "pep_1974" ~ "pep_Seq1",
    pep_id == "pep_2002" ~ "pep_Seq2",
    
    TRUE ~ as.character(pep_id)
  )) |> 
   mutate(across(where(is.numeric), ~replace_na(.,0))) |> 
  mutate(across(where(is.numeric), ~round(., 2)))
  

# --- Verificação Final ---
cat("\nDimensões da matriz após gap-filling:", dim(pep_matrix_filled), "\n")
cat("Dimensões da matriz final (com moléculas anotadas):", dim(pep_matrix_final_annotate), "\n")
# Verifica se a coluna foi realmente removida
cat("Colunas na matriz final:", paste(names(pep_matrix_final_annotate), collapse = ", "), "\n")


matriz_anotada <- as.data.frame(pep_matrix_final_annotate)

print(head(matriz_anotada))

matriz_final_anotada <- "matriz_anotada.xlsx"

write.xlsx(
  matriz_anotada,
  file = matriz_final_anotada,
  asTable = TRUE,
  overwrite = TRUE
)

```


#Heatmap

```{r}
heatmap_data <- pep_matrix_final_annotate %>%
  tibble::column_to_rownames("pep_id")
heatmap_matrix <- as.matrix(heatmap_data)

# Identifica e remove as linhas com variância zero.
sds <- apply(heatmap_matrix, 1, sd)
# Mantemos apenas as linhas cujo desvio padrão é maior que zero.
heatmap_matrix_filtrada <- heatmap_matrix[sds > 0, ]

cat("Número de linhas original:", nrow(heatmap_matrix), "\n")
cat("Número de linhas após remover variância zero:", nrow(heatmap_matrix_filtrada), "\n")

peptaibols_unicos <- pep_matrix_filled %>%
  pivot_longer(cols = -pep_id, names_to = "specie", values_to = "log10_area") %>%
  filter(log10_area > 0) %>%
  group_by(pep_id) %>%
  summarise(
    n_species = n(), # Conta o número de espécies
    specie_unica = first(specie), # Guarda o nome da espécie
    area_detectada = first(log10_area) # Guarda a área
  ) %>%
  filter(n_species == 1) %>%
  mutate(area_detectada = round(area_detectada, 2)) |> 
  arrange(specie_unica)

cat("--- Peptaibols Únicos Encontrados ---\n")
print(peptaibols_unicos)

pep_unico <- as.data.frame(peptaibols_unicos)
peptaibols_unicos <- "peptaibols_unicos.xlsx"

write.xlsx(
  pep_unico,
  file = peptaibols_unicos,
  asTable = TRUE,
  overwrite = TRUE
)

minha_cor <- colorRampPalette(brewer.pal(n = 9, name = "YlGnBu"))(50)

heatmap_peptaibols <- pheatmap(
  heatmap_matrix_filtrada, # <--- Use a matriz limpa aqui
  scale = "row",
  color = minha_cor,
  clustering_distance_rows = "correlation",
  clustering_distance_cols = "euclidean",
  fontsize_row = 6,
  fontsize_col = 10,
  angle_col = 45,
  border_color = "grey60",
  filename = "heatmap_peptaibols.tiff",
  width = 10,
  height = 12
)



```





